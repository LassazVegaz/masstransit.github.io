(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{416:function(e,n,s){"use strict";s.r(n);var i=s(10),t=Object(i.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"guidance"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#guidance"}},[e._v("#")]),e._v(" Guidance")]),e._v(" "),n("p",[e._v("The following recommendations should be considered "),n("em",[e._v("best practices")]),e._v(" for building applications using MassTransit, specifically with RabbitMQ.")]),e._v(" "),n("ul",[n("li",[e._v("Published messages are routed to a receive endpoint queue by message type, using exchanges and exchange bindings. A service's receive endpoints do not affect other services or their receive endpoints, as long as they do not share the same queue.")]),e._v(" "),n("li",[e._v("Consumers and sagas should have their own receive endpoint, with a unique queue name\n"),n("ul",[n("li",[e._v("Each receive endpoint maps to one queue")]),e._v(" "),n("li",[e._v("A queue may contain more than one message type, the message type is used to deliver the message to the appropriate consumer configured on the receive endpoint.")]),e._v(" "),n("li",[e._v("If a received message is not handled by a consumer, the skipped message will be moved to a skipped queue, which is named with a _skipped suffix.")])])]),e._v(" "),n("li",[e._v("When running multiple instances of the same service\n"),n("ul",[n("li",[e._v("Use the same queue name for each instance")]),e._v(" "),n("li",[e._v("Messages from the queue will be load balanced across all instances (the "),n("em",[e._v("competing consumer")]),e._v(" pattern)")])])]),e._v(" "),n("li",[e._v("If a consumer exception is thrown, the faulted message will be moved to an error queue, which is named with the _error suffix.")]),e._v(" "),n("li",[e._v("The number of concurrently processed messages can be up to the "),n("em",[e._v("PrefetchCount")]),e._v(", depending upon the number of cores available.")]),e._v(" "),n("li",[e._v("For temporary receive endpoints that should be deleted when the bus is stopped, use "),n("em",[e._v("TemporaryEndpointDefinition")]),e._v(" as the receive endpoint definition.")]),e._v(" "),n("li",[e._v("To configure "),n("em",[e._v("PrefetchCount")]),e._v(" higher than the desired concurrent message count, add "),n("em",[e._v("UseConcurrencyLimit(n)")]),e._v(" to the configuration. "),n("em",[e._v("This must be added before any consumers are configured.")]),e._v(" Depending upon your consumer duration, higher values may greatly improve overall message throughput.")])]),e._v(" "),n("h3",{attrs:{id:"receive-endpoints"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#receive-endpoints"}},[e._v("#")]),e._v(" Receive Endpoints")]),e._v(" "),n("p",[e._v("Consumers and sagas should be configured on their own receive endpoints. Running multiple unrelated consumers or sagas on a single receive endpoint is highly discouraged.")]),e._v(" "),n("p",[e._v("Running multiple instances of a service should use the same endpoint names for the same consumers and sagas to allow service instances to load balance messages from the same queue.")]),e._v(" "),n("p",[e._v("Calling "),n("code",[e._v("ConfigureEndpoints")]),e._v(" will generate a queue name for each receive endpoint based on the consumer, saga, or activity name (removing the "),n("em",[e._v("Consumer")]),e._v(", "),n("em",[e._v("Saga")]),e._v(", or "),n("em",[e._v("Activity")]),e._v(" suffix) using the specified "),n("em",[e._v("endpoint name formatter")]),e._v(" and configure the consumers and sagas using their respective endpoints.")]),e._v(" "),n("p",[e._v("In specialized scenarios where multiple consumers are closely related and have similar partitioning or ordering concerns, running those consumers on the same receive endpoint might be acceptable.")])])}),[],!1,null,null,null);n.default=t.exports}}]);